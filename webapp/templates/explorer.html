-{% extends "layout.html" %} {% block head %} {{ super() }}
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.11.0/d3.js"></script>
<!-- minified at https://cdnjs.cloudflare.com/ajax/libs/d3/4.11.0/d3.min.js -->
<!-- graphviz in javascript -->
<script type="text/javascript" src="{{ url_for('static', filename='viz/viz-1.8.0.js') }}"></script>
<script type="text/javascript" src="{{ url_for('static', filename='d3-zoom/d3-zoom.js') }}"></script>

<script type="text/javascript" src="{{ url_for('static', filename='saveSvgAsPng/saveSvgAsPng.js') }}"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/2.6.3/svg.js"></script>

<style>
  .node {
    cursor: pointer;
  }

  .node circle {
    fill: grey;
    stroke: steelblue;
    stroke-width: 1.5px;
  }

  .node:hover circle,
  .node.hover circle {
    fill: #fff;
    stroke-width: 2px;
  }

  .node circle.node.active {
    fill: lightsteelblue;
  }

  .node:hover circle.node.active,
  .node.hover circle.node.active {
    fill: white;
  }

  svg text {
    -webkit-user-select: none;
    /* Safari */
    -moz-user-select: none;
    /* Firefox */
    -ms-user-select: none;
    /* IE10+/Edge */
    user-select: none;
    /* Standard */
  }

  .edge,
  .edge text,
  .node text {
    font: 10px sans-serif;
    pointer-events: none;
    /* don't block clicks on underlying node */
  }

  .link {
    fill: none;
    stroke: #ccc;
    stroke-width: 1.5px;
  }


  div.tooltip {
    position: absolute;
    text-align: center;
    width: 60px;
    height: 28px;
    padding: 2px;
    font: 12px sans-serif;
    background: lightsteelblue;
    border: 0px;
    border-radius: 8px;
    pointer-events: none;
  }

  #supergraph {
    border: 1px dashed black;
    text-align: center;
  }

  #concrete_graph {
    border: 1px dashed black;
    text-align: center;
  }

  #svg_supergraph {
    width: 100%;
    height: 1080;
  }

  #svg_concrete_graph {
    width: 100%;
    height: 1080;
  }
</style>
{% endblock %} {% block title %}Explore!{% endblock %} {% block body %}
<div class="container p-3">
  <button id='btn_reset' class="btn btn-info">Reset</button>
  <button id='btn_export_dendrogram' class="btn btn-info">Export Dendrogram</button>
  <button id='btn_export_supergraph' class="btn btn-info">Export Super Graph</button>
  <button id='btn_export_concrete_dot' class="btn btn-info">Export Last Selected Concrete Graph .dot</button>
  <button id='btn_export_supergraph_dot' class="btn btn-info">Export Super Graph .dot</button>
  <button id='btn_expand_all' class="btn btn-info">Expand All</button>
  <button id='btn_collapse_all' class="btn btn-info">Collapse All</button>
   <input id='search_bar' type="text" placeholder="Search.." name="search">
   <button id='search_button' type="submit">Submit</button>
</div>

<svg id="d3-main" style="border: 1px dashed black;"></svg>
<div id="supergraph"></div>
<div id="concrete_graph"></div>
{% endblock %} {% block end_of_body %}
<script type="text/javascript">
  var shownDuplicateMessage = false; // only show duplicate vertex warning once

  var margin = {
      top: 20,
      right: 120,
      bottom: 20,
      left: 120
    },
    width = 960 - margin.right - margin.left,
    height = 800 - margin.top - margin.bottom;

  var i = 0,
    duration = 750,
    root,
    recieved_data;

  var viewbox = "0 0 " + (width + margin.right + margin.left) + " " + (height + margin.top + margin.bottom);
  var svg = d3.select("#d3-main")
    .attr("viewBox", viewbox)
    .style("fill", "none")


  var tooltip_div = d3.select("body").append("div")
    .attr("class", "tooltip")
    .style("opacity", 0);

  var zoom = d3.zoom()
    .scaleExtent([1 / 2, 4])
    .on("zoom", zoomed);

  svg.style("fill", "none")
    .style("pointer-events", "all")
    .call(zoom);

  var g_container = svg.append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  var g_root = g_container.append("g");

  function zoomed() {
    g_root.attr("transform", d3.event.transform);
  }

  function zoomed_supergraph() {
    d3.select('#graph0').attr("transform", d3.event.transform);
  }

  function zoomed_concrete_graph() {
    d3.select('#graph1').attr("transform", d3.event.transform);
  }

  $('#btn_reset').click(function() {
    zoom.transform(svg, d3.zoomIdentity.scale(1))
  });


  $('#search_button').click(function() {
    var val = document.getElementById('search_bar').value;
    highlight_label_in_supergraph(val);
    highlight_label_in_concrete_graph(val);
  });

  function highlight_label_in_supergraph(searched_label) {

    var superGraphSvg = SVG.get('svg_supergraph');
    var text_elements = superGraphSvg.select("text");
    var item_found = false
    // handle nodes
    // get active clusters!
    var activeNodes = {};
    var graph_objects = superGraphSvg.select("g").members
    for (i = 0; i < graph_objects.length; i++) {
      var obj = graph_objects[i];
      if (obj.node.id.includes("cluster")){
        activeNodes[obj.node.id] = obj;
      }
    }
    var nodes2highligth = []
    for (i = 0; i < recieved_data.clusters.length; i++) {
      cluster_node = recieved_data.clusters[i];
      if (!(cluster_node.id in activeNodes)){
        continue;
      }

      cluster_concrete_nodes = new Set(cluster_node.vertices);
      // search labels of the super-state concrete nodes
      for (var j = 0; j < recieved_data.vertices.length; j++) {
        node = recieved_data.vertices[j];
        if (cluster_concrete_nodes.has(node[0])){
          if (node[1].label !== undefined && node[1].label.includes(searched_label)){
            nodes2highligth.push(cluster_node.id);
            item_found = true;
            break;
          }
        }
      }
      // search labels of the super-state concrete edges
      for (var j = 0; j < recieved_data.edges.length; j++) {
        edge = recieved_data.edges[j];
        if (cluster_concrete_nodes.has(edge[0]) && cluster_concrete_nodes.has(edge[1])){
          if (edge[2].label !== undefined && edge[2].label.includes(searched_label)){
            nodes2highligth.push(cluster_node.id);
            item_found = true;
            break;
          }
        }
      }
    }

    nodes2highligth.forEach(function(elem){
      elements = superGraphSvg.select("[id=" + elem + "] polygon")
      elements.animate({
        ease: '<>'
      }).attr({
        fill: 'lightblue'
      }).animate().attr({
        fill: '#ffffff'
      }).animate().attr({
        fill: 'lightblue'
      })
    });

    // handle edges
    text_elements.members.forEach( function(text_element){
      var text = text_element.node.innerHTML;
      var highlight_element = false;
      if (text.includes(searched_label)){
        var element = text_element.node.parentElement;
        if (element.attributes.class.value == "node"){
          return;
        }
        item_found = true;
        if (highlight_element = true){
          text_element.animate({
            ease: '<>'
          }).attr({
            fill: 'blue'
          }).animate().attr({
            fill: '#ffffff'
          }).animate().attr({
            fill: 'blue'
          });
        }
      }
    });

    if (!item_found){
      alert("label '" + searched_label + "' is not in the model!")
    }
  }


  function highlight_label_in_concrete_graph(searched_label){

    var concreteGraphSvg = SVG.get('svg_concrete_graph');
    if (concreteGraphSvg == null){
      return;
    }
    var text_elements = concreteGraphSvg.select("text");
    // handle edges
    text_elements.members.forEach( function(text_element){
      var text = text_element.node.innerHTML;
      var highlight_element = false;
      if (text.includes(searched_label)){
        var element = text_element.node.parentElement;
        // if (element.attributes.class.value == "node"){
        //   return;
        // }
        if (highlight_element = true){
          text_element.animate({
            ease: '<>'
          }).attr({
            fill: 'blue',
          }).animate().attr({
            fill: '#ffffff',
          }).animate().attr({
            fill: 'blue',
          });
        }
      }
    });
  }

  $('#btn_export_dendrogram').click(function() {
    saveSvgAsPng(document.getElementById("d3-main"), "diagram.png", {
      scale: 1,
      backgroundColor: 'white'
    });
  });


  $('#btn_export_supergraph').click(function() {
    saveSvgAsPng($('#supergraph').children().first()[0], "diagram.png", {
      scale: 1,
      backgroundColor: 'white'
    });
  });

  $('#btn_export_supergraph_dot').click(function() {
    // NOTE: this function is exported by saveSvgAsPng.js
    download("superstate_graph.dot", "data:text/vnd.graphviz," + lastSupergraphGraphviz);
  });

  $('#btn_export_concrete_dot').click(function() {
    // NOTE: this function is exported by saveSvgAsPng.js
    download("concrete_graph.dot", "data:text/vnd.graphviz," + lastSelectedConcreteGraph);
  });


  $(document).keydown(function(e) {
    switch (e.which) {
      case 38: // up
        document.getElementById('btn_reset').scrollIntoView({
          block: 'start',
          behavior: 'smooth'
        });
        break;

      case 40: // down
        document.getElementById('supergraph').scrollIntoView({
          block: 'start',
          behavior: 'smooth'
        });
        document.getElementById('concrete_graph').scrollIntoView({
          block: 'start',
          behavior: 'smooth'
        });
        break;

      default:
        return; // exit this handler for other keys
    }
    e.preventDefault(); // prevent the default action (scroll / move caret)
  });



  function expandAll() {
    expand(root);
  }

  function expand(d) {
    var children = (d.children) ? d.children : d._children;
    if (d._children) {
      d.children = d._children;
      d._children = null;
    }
    if (children)
      children.forEach(expand);
  }

  var lastSupergraphGraphviz;
  var lastSelectedConcreteGraph;
  var concrete_nodes_dic = {}
  // declares a tree layout and assigns the size
  var treemap = d3.tree().size([height, width]);
  d3.json("{{ url_for('get_result', result_id=result_id) }}", function(error, data) {
    if (error) throw error;
    console.log(data);
    recieved_data = data;
    // set up for graph view

    // mapping of: cluster i id -> cluster struct (e.g. verices: [vertex i1, vertex i2, ..., ik])
    var idToCluster = {};
    data.clusters.forEach(function(cluster, index) {
      // name -> cluster mapping
      idToCluster[cluster.id] = cluster;
    });
    // TODO(roee): hack! get better data from server-side
    // create fake, unconnected clusters for stand-alone vertices for the super-state graph
    // to allow us to treat them the same when creating the super-state graph
    data.vertices.forEach(function(vertex) {
      var vertexId = vertex[0],
        attrs = vertex[1];
      concrete_nodes_dic[vertexId] = attrs
      // TODO: what if there is a cluster with the same name?!?!
      if (!idToCluster[vertexId]) {
        // TODO: name from real graph
        idToCluster[vertexId] = {
          vertices: [vertexId],
          name: vertexId,
          id: vertexId,
          attrs: attrs,
          isConcrete: true
        };
      }
    });

    // set up tree view
    treeData = data['cluster_tree'];
    // Assigns parent, children, height, depth
    root = d3.hierarchy(treeData, function(d) {
      return d.children;
    });
    console.log(root);
    //form x and y axis
    root.x0 = 0;
    root.y0 = height / 2;

    function collapse(d) {
      if (d.children) {
        d._children = d.children;
        d._children.forEach(collapse);
        d.children = null;
      }
    }
    // Toggle children on click.
    function clickOnDendrogram(d) {
      document.getElementById('tree-' + d.data.id).classList.remove('hover');
      if (d.children) {
        // collapse
        d._children = d.children;
        d.children = null;
        update(d);
      } else {
        // expand
        d.children = d._children;
        d._children = null;

        update(d);
        superGraphSvg = SVG.get('svg_supergraph')
        clicked_cluster = idToCluster[d.data.id]

        for (var i = 0; i < clicked_cluster.vertices.length; i++) {
          elements = superGraphSvg.select("[id='" + clicked_cluster.vertices[i] + "'] ellipse")
          elements.attr({
            'fill': '#ffffff'
          })
          elements.animate({
            ease: '<>'
          }).attr({
            fill: '#ffcc00'
          }).animate().attr({
            fill: '#ffffff'
          }).animate().attr({
            fill: '#ffcc00'
          })

          elements = superGraphSvg.select("[id=cluster_" + clicked_cluster.vertices[i] + "] polygon")
          elements.animate({
            ease: '<>'
          }).attr({
            fill: '#ffcc00'
          }).animate().attr({
            fill: '#ffffff'
          }).animate().attr({
            fill: '#ffcc00'
          })
        }

        // concrete graph
        concreteGraphSvg = SVG.get('svg_concrete_graph');
        clicked_cluster = idToCluster[d.data.id];

        for (var i = 0; i < clicked_cluster.vertices.length; i++) {

          node = clicked_cluster.vertices[i]
          console.log('is concrete:' + !node.isConcrete);
          if (!node.isConcrete){
              continue;
          }
          elements = concreteGraphSvg.select("[id='" + clicked_cluster.vertices[i] + "'] ellipse")
          elements.attr({
            'fill': '#ffffff'
          })
          elements.animate({
            ease: '<>'
          }).attr({
            fill: '#ffcc00'
          }).animate().attr({
            fill: '#ffffff'
          }).animate().attr({
            fill: '#ffcc00'
          })

        }


      }

    }

    // Toggle children on click.
    function rightClickOnDendrogram(d) {
      document.getElementById('tree-' + d.data.id).classList.remove('hover');
      // collapse
      var clicked_cluster = idToCluster[d.data.id];

      var colors_dic = {};

      var children = d.children;
      if (!d.children){
        children = d._children;
      }
      for  (var i=0; i< children.length;i++){
        child =  idToCluster[children[i].data.id];;
        for  (var j=0; j < child.vertices.length;j++){
          colors_dic[child.vertices[j]] = i;
        }
      }

      var concrete_nodes = clicked_cluster.vertices.slice(0,clicked_cluster.vertices.length);
      var set1 = new Set(concrete_nodes);
      // alert(concrete_nodes);
      for (var j = 0; j < concrete_nodes.length; j++) {
        console.log('node:' + concrete_nodes[j]);
      }

      var concrete_edges = [];
      var shape_dic = {};
      var add_init = false, add_term = false;
      var in_crossing_edges = {}, out_crossing_edges = {};

      for (var i = 0; i < data.edges.length; i++) {
        edge = data.edges[i];
        if (set1.has(edge[0]) && set1.has(edge[1])) {
          concrete_edges.push(edge); // Keep both edge ends in cluster
          continue;
        }
        if (!set1.has(edge[0]) && !set1.has(edge[1])) {
          continue; // SKIP: both edge ends in cluster
        }
        n_edge = [];
        var attr = Object.assign({}, edge[2]);
        if (set1.has(edge[0])){
          n_edge.push(edge[0]);
          n_edge.push("1001"); //TODO: use a better solution then using random id
          n_edge.push(attr);
          add_term=true;
          if (!(edge[0] in out_crossing_edges)){
            out_crossing_edges[edge[0]] = []
          }
          out_crossing_edges[edge[0]].push(n_edge);
        }
        if (set1.has(edge[1])){
          n_edge.push("1000"); //TODO: use a better solution then using random id
          n_edge.push(edge[1]);
          n_edge.push(attr);
          add_init=true;
          if (!(edge[1] in in_crossing_edges)){
            in_crossing_edges[edge[1]] = []
          }
          in_crossing_edges[edge[1]].push(n_edge);
        }
        // concrete_edges.push(n_edge);
      }

      handle_crossing_edges(in_crossing_edges, concrete_edges);
      handle_crossing_edges(out_crossing_edges, concrete_edges);

      if (add_init){
        concrete_nodes.push("1000");
        concrete_nodes_dic["1000"] = {"label" : "IN", "style":"dashed"};
        shape_dic["1000"] = "invtriangle";
      }
      if (add_term){
        concrete_nodes.push("1001");
        concrete_nodes_dic["1001"] = {"label" : "OUT", "style":"dashed"};
        shape_dic["1001"] = "triangle";
      }

      assign_width_to_concrete_edges(concrete_edges);
      var svgString = concreteGraphToGraphviz(concrete_nodes, concrete_edges, colors_dic, shape_dic);
      lastSelectedConcreteGraph = svgString;
      try{
        present_concrete_graph(svgString, concrete_nodes, concrete_edges);
      }
      catch(err) {
          download("concrete_graph.dot", "data:text/vnd.graphviz," + svgString);
          console.log(err);
          if (err.indexOf("Cannot enlarge memory arrays") >=0){
            alert("Model is too large to present - downloading dot file");
         }

     }
      // if (children > 1) {
      //   for (var i = 0; i < clicked_cluster.vertices.length; i++) {}
      // }
    }

    function assign_width_to_concrete_edges(concrete_edges){

      var max = null;
      var min = null;
      concrete_edges.forEach(function(edge){
        var w = edge[2].width;
        if (w == undefined){
          return;
        }
        if (max == null){
          max = w;
          min = w;
        }
        if (w > max){
          max = w;
        }
        if (w < min){
          min = w;
        }
      });
      if (max-min > 0){
      concrete_edges.forEach(function(edge){
        var w = edge[2].width;
        if (w == undefined){
          w = min;
        }
        edge[2].penwidth = 0.5 + 5.0*(w-min)/(max-min);
      });
      }
    }

    function handle_crossing_edges(out_crossing_edges, concrete_edges){
      // Crossing edges, are edges that extend beyond the super-state model
      // these, are marked in a different style, and connected to
      // dummy start and terminal nodes
      Object.keys(out_crossing_edges).forEach(function(source) {
        var edges = out_crossing_edges[source];
        var labels2weights = {};
        edges.forEach(function(e){
            var l = e[2].label;
            var w = e[2].weight;
            if (w == null){
              w = 0;
            }
            if (!(l in labels2weights)){
              labels2weights[l] = 0;
            }
            labels2weights[l] += w;
        });
        var labels = "";
        var total = 0;
        // Sort edges by visits!
        var transitions_names = Object.keys(labels2weights).map(function(key) {
            return [key, labels2weights[key]];
        });

        // Sort the array based on the second element
        transitions_names.sort(function(first, second) {
            return second[1].weight - first[1].weight;
        });
        transitions_names.reverse();
        transitions_names.forEach(function(edge_tuple) {
          labels += edge_tuple[0] + " weight:" + edge_tuple[1] + "\n";
          total += edge_tuple[1];
        });
        var edge = [edges[0][0], edges[0][1], {"label": labels, "weight": total, "style":"dotted"}];
        concrete_edges.push(edge);
      });
    }

    root.children.forEach(collapse);

    update(root);

    function update(source) {
      updateTree(source);
      updateGraph(source);
    }

    function updateTree(source) {


      // Assigns the x and y position for the nodes
      var treeData = treemap(root);

      // Compute the new tree layout.
      var nodes = treeData.descendants(),
        links = treeData.descendants().slice(1);

      // Normalize for fixed-depth.
      nodes.forEach(function(d) {
        d.y = d.depth * 180
      });

      // ****************** Nodes section ***************************

      // Update the nodes...
      var node = g_root.selectAll('g.node')
        .data(nodes, function(d) {
          return d.id || (d.id = ++i);
        });

      // Enter any new modes at the parent's previous position.
      var nodeEnter = node.enter().append('g')
        .attr('class', 'node')
        .attr('id', function(d) {
          return 'tree-' + d.data.id;
        })
        .attr("transform", function(d) {
          return "translate(" + source.y0 + "," + source.x0 + ")";
        })
        .on('click', clickOnDendrogram);

      nodeEnter.on('contextmenu', rightClickOnDendrogram);

      // Add Circle for the nodes
      nodeEnter.append('circle')
        .attr('class', 'node')
        .on("mouseover", function(d) {
          //console.log(d.data);
          tooltip_div.transition()
            .duration(200)
            .style("opacity", .9);

          var cluster = idToCluster[d.data.id];
          //console.log(cluster);
          // vertices_no_initial = cluster.vertices.filter(vertex => vertex != "initial") //TODO: remove this line
          tooltip_div.html('#Nodes: ' + (cluster.vertices.length))
            .style("left", (d3.event.pageX) + "px")
            .style("top", (d3.event.pageY - 28) + "px");
        })
        .on("mouseout", function(d) {
          tooltip_div.transition()
            .duration(500)
            .style("opacity", 0);
        })
        .attr('r', 1e-6)
        .classed('active', function(d) {
          return d._children !== undefined && d._children !== null;
        });

      // Add labels for the nodes
      nodeEnter.append('text')
        .attr("dy", ".35em")
        .attr("fill", "#202020")
        .attr("x", function(d) {
          return d.children || d._children ? -13 : 13;
        })
        .attr("text-anchor", function(d) {
          return d.children || d._children ? "end" : "start";
        })
        .text(function(d) {
          return d.data.name;
        });

      // UPDATE
      var nodeUpdate = nodeEnter.merge(node);

      // Transition to the proper position for the node
      nodeUpdate.transition()
        .duration(duration)
        .attr("transform", function(d) {
          return "translate(" + d.y + "," + d.x + ")";
        });

      // Update the node attributes and style
      nodeUpdate.select('circle.node')
        .attr('r', 10)
        .classed('active', function(d) {
          return d._children !== undefined && d._children !== null;
        })
        .classed('hover', false)
        .attr('cursor', 'pointer');


      // Remove any exiting nodes
      var nodeExit = node.exit().transition()
        .duration(duration)
        .attr("transform", function(d) {
          return "translate(" + source.y + "," + source.x + ")";
        })
        .remove();

      // On exit reduce the node circles size to 0
      nodeExit.select('circle')
        .attr('r', 1e-6);

      // On exit reduce the opacity of text labels
      nodeExit.select('text')
        .style('fill-opacity', 1e-6);

      // ****************** links section ***************************

      // Update the links...
      var link = g_root.selectAll('path.link')
        .data(links, function(d) {
          return d.id;
        });

      // Enter any new links at the parent's previous position.
      var linkEnter = link.enter().insert('path', "g")
        .attr("class", "link")
        .attr('d', function(d) {
          var o = {
            x: source.x0,
            y: source.y0
          }
          return diagonal(o, o)
        });

      // UPDATE
      var linkUpdate = linkEnter.merge(link);

      // Transition back to the parent element position
      linkUpdate.transition()
        .duration(duration)
        .attr('d', function(d) {
          return diagonal(d, d.parent)
        });

      // Remove any exiting links
      var linkExit = link.exit().transition()
        .duration(duration)
        .attr('d', function(d) {
          var o = {
            x: source.x,
            y: source.y
          }
          return diagonal(o, o)
        })
        .remove();

      // Store the old positions for transition.
      nodes.forEach(function(d) {
        d.x0 = d.x;
        d.y0 = d.y;
      });

      // Creates a curved (diagonal) path from parent to the child nodes
      function diagonal(s, d) {

        path = `M ${s.y} ${s.x}
            C ${(s.y + d.y) / 2} ${s.x},
              ${(s.y + d.y) / 2} ${d.x},
              ${d.y} ${d.x}`

        return path
      }
    }

    function updateGraph(source) { //TODO add concrete node creation over here as well
      // generate the supergraph - its nodes and then edges
      // derived from the graph and clusters
      console.log('Updating super-state graph');
      // the clusters with no children are the super-cut
      var supergraphNodes = getActiveClusters(root);
      //console.log(supergraphNodes);
      //console.log(idToCluster);

      // To construct the edges, we'll map each edge in the original graph
      // into an edge in the supergraph.

      // map of vertex id -> cluster in original graph
      var vertexToNode = {};

      supergraphNodes.forEach(function(d3Node) {
        var clusterId = d3Node.data.id;
        // for every vertex in the cluster, map it to the cluster
        idToCluster[clusterId].vertices.forEach(function(vertex) {
          if (vertexToNode[vertex] !== undefined) {
            if (!shownDuplicateMessage) {
              alert('vertex showed up in two clusters!');
              shownDuplicateMessage = true;
            }
            // if vertex is assiged to a cluster with an id smaller than ours
            // leave it be. otherwise map the vertex to us
            if (vertexToNode[vertex] < clusterId) {
              return;
            }
          }
          vertexToNode[vertex] = clusterId;
        });
      }); // supergraphNodes.forEach


      // map of source -> dest edges in the supergraph
      // generated from map of edges
      var superEdges = {};

      // for each edge in the original graph, create/update superedge or discard
      // if the edge is internal to a cluster
      data.edges.forEach(function(edge) {
        //console.log(edge);
        // map src, dest from graph nodes to clusters
        var srcNode = vertexToNode[edge[0]],
          dstNode = vertexToNode[edge[1]];

        if (srcNode === dstNode) {
          // self-edges are ok only for concrete vertices
          if (!idToCluster[srcNode].isConcrete) {
            return;
          }
        }

        var existingEdges = superEdges[srcNode];
        if (existingEdges === undefined) {
          //console.log('First edge for', srcNode);
          existingEdges = [];
        }

        existingEdges.push({
          dst: dstNode,
          attrs: edge[2]
        });
        superEdges[srcNode] = existingEdges;
      });

      var svgString = supergraphToGraphviz(supergraphNodes, superEdges);//Viz(dotContent); // TODO: FIXME add var from webapp_config.py
      document.getElementById('supergraph').innerHTML = svgString;
      supergraph_svg_elem = $("#supergraph").find("svg")[0];
      supergraph_svg_elem.id = 'svg_supergraph';

      supergraphNodes.forEach(function(d3Node) {
        var nodeElement = $('#' + d3Node.data.id),
          dendrogramElement = $('#tree-' + d3Node.data.id);
        if (!d3Node.data.isConcrete) {

          // node is a cluster, make it so click on node in super-state graph expands it
          nodeElement.on('click', function(e) {
            console.log('click on ' + d3Node.data.id);
            var evt = new MouseEvent("click");
            // [0] is for raw DOM node instead of jquery since d3 doesn't use jquery
            // so dendrogramElement.click() doesn't work...
            dendrogramElement[0].dispatchEvent(evt);
          });
          nodeElement.on('mouseenter', function(e) {
            // TODO: make sure all other fake-hovers are removed
            console.log('hover on');
            // note: jquery addClass/removeClass don't work inside svg :(
            dendrogramElement[0].classList.add("hover");
          });
          nodeElement.on('mouseleave', function(e) {
            console.log('hover off');
            console.log(dendrogramElement);
            // note: jquery addClass/removeClass don't work inside svg :(
            dendrogramElement[0].classList.remove('hover');
          })
        }
        // for all nodes: right click = collapse to parent
        nodeElement.on('contextmenu', function(e) {

          if (d3Node.parent !== undefined && d3Node.parent !== null) {
            clickOnDendrogram(d3Node.parent);
            e.preventDefault();
          }
        });

      });

      svg_supergraph = d3.select('#svg_supergraph');
      zoom_supergraph = d3.zoom()
        .scaleExtent([1 / 2, 4])
        .on("zoom", zoomed_supergraph);

      svg_supergraph.style("fill", "none")
        .style("pointer-events", "all")
        .call(zoom_supergraph);

      // read SVG transform matrix, convert to d3-zoom object, set as initial zoom. ugh.
      // this stops the super-state graph jumping on first zoom
      var initialTransform = document.getElementById('graph0').transform.baseVal.consolidate().matrix;
      if (initialTransform.a != initialTransform.d) {
        alert('svg zoom on supergraph does not preserve aspect ratio. UNSUPPORTED!');
      }
      var asZoomTransform = d3.zoomIdentity.translate(initialTransform.e, initialTransform.f).scale(initialTransform.a);
      // set initial transform
    }

    function graphvizEscape(str) {
      return '"' + str.replace(/\n/g, '\\n') + '"';
    }

    function mergeAttributes(attributes) {
      // single edge, use its attributes
      if (attributes.length == 1) {
        return attributes[0];
      }


      // ## get labels and create labels 2 weights
      var labels = attributes.map(function(item) {
        var st = [];
        st.push(item.label);
        if (item.weight !== undefined) {
          st.push(item.weight);
        }
        return st;
      }).filter(function(v) {
        return v !== undefined;
      });

      var labels_map = {};
      labels.forEach(function(label){
        if ( ! (label[0] in labels_map) ){
          labels_map[label[0]] = 0
        }
        if (label.length == 2){
          labels_map[label[0]] += label[1]
        }
      });


      // ## sort labels by weights
      var super_tran_label = "";
      // Create items array
      var items = Object.keys(labels_map).map(function(key) {
         return [key, labels_map[key]];
      });
      // Sort the array based on weight
      items.sort(function(first, second) {
         return second[1] - first[1];
      });
      var top3items = items.slice(0, 3);
      top3items.forEach(function(item){
        super_tran_label += item[0] + ":" + item[1] + "\n";
      });
      if (items.length > 3){
        super_tran_label += "...";
      }

      var weights = attributes.map(function(item) {
        return item.weight;
      }).filter(function(v) {
        return v !== undefined;
      });
      // compute weight of all edges, to add a total attribute
      var sum = weights.reduce(function(a, b) {return a + b}, 0);

      return {
        label: super_tran_label,
        weight: sum
      };
    }

    function attributesToGraphViz(attributes) {
      // add attributes
      var attributeList = [];
      if (attributes.color !== undefined) {
        attributeList.push({
          name: 'color',
          value: attributes.color
        });
      }
      if (attributes.shape !== undefined) {
        attributeList.push({
          name: 'shape',
          value: attributes.shape
        });
      }
      if (attributes.style !== undefined) {
        // wrap with quotes
        attributeList.push({
          name: 'style',
          value: graphvizEscape(attributes.style)
        });
      }
      if (attributes.label !== undefined) {
        // wrap with quotes
        var label_val = attributes.label;
        if (attributes.weight !== undefined){
          label_val += "\nweight:" + attributes.weight;
        }
        label_val = graphvizEscape(label_val);
        attributeList.push({
          name: 'label',
          value: label_val
        });
      }
      if (attributes.id !== undefined) {
        attributeList.push({
          name: 'id',
          value: graphvizEscape(attributes.id)
        });
      }
      if (attributes.penwidth !== undefined) {
        <!--max_width = Math.max(Math.min(attributes.penwidth, 5.5),0.5);-->
        attributeList.push({
          name: 'penwidth',
          value: attributes.penwidth
        });
      }

      if (attributeList.length > 0) {
        // transform attributes to strings
        var attributeStrings = attributeList.map(function(item) {
          return item.name + '=' + item.value;
        });

        return attributeStrings.join(',');
      }
      return '';
    }

    // convert supergraphNodes, superEdges into a .dot file, render to svg
    // NOTE: to style the graph use CSS (see '.node text' above for example)
    function supergraphToGraphviz(supergraphNodes, superEdges) {
      var graphvizOutput = '';
      // TODO: get smart name for result (e.g. model name)
      for (var key in superEdges) {
          // check if the property/key is defined in the object itself, not in parent
          if (superEdges.hasOwnProperty(key)) {
            var weights =  superEdges[key].forEach(function(edge, index) {
              return edge.attrs.weight;
            });
          }
      }

      graphvizOutput += 'Digraph "Supergraph" {\n';

      // assign a number to every cluster for the graphviz graph, which is
      var supernodeToGraph = {};

      supergraphNodes.forEach(function(node, index) {
        // update mapping for edge lookups
        supernodeToGraph[node.data.id] = index;

        // prepare graphviz node
        var attributes;
        if (node.data.hasOwnProperty('attrs')) {
          // server-side attributes, use these
          attributes = attributesToGraphViz(node.data.attrs)
        } else {
          // no server-side attributes
          attributes = 'label=' + graphvizEscape(node.data.name) + ',shape=rectangle'
        }
        // if node is a cluster and not a concrete vertex, give it an id so we can hook up to the dendrogram
        if (attributes.length > 0) {
          attributes += ','
        }
        attributes += 'id=' + graphvizEscape(node.data.id);
        // write node to graphviz;
        graphvizOutput += '' + index + ' [' + attributes + '];\n';
      });

      for (var srcNode in superEdges) {
        if (superEdges.hasOwnProperty(srcNode)) {
          // join together edges from the original graph to form edges from/to clusters
          // for each target vertex, store array of attributes from edges contributing to this super-edge
          var finalEdges = {};
          superEdges[srcNode].forEach(function(edgeTarget) {
            // check if this edge is inserted already
            // this can happen if supernode contains multiple vertices that
            // had edges to vertices in the same dst supernode
            // here is where we de-duplicate
            if (finalEdges[edgeTarget.dst] !== undefined) {
              // existing edge, add attributes
              finalEdges[edgeTarget.dst].push(edgeTarget.attrs)
            } else {
              // new edge
              finalEdges[edgeTarget.dst] = [edgeTarget.attrs];
            }
          });
          // write out the final super-edges for this source node
          for (var target in finalEdges) {
            if (finalEdges.hasOwnProperty(target)) {
              // add attributes string
              var merged = mergeAttributes(finalEdges[target]);
              var attributes = attributesToGraphViz(merged);

              // add the edge to the total output
              graphvizOutput += '' + supernodeToGraph[srcNode] + ' -> ' + supernodeToGraph[target];

              graphvizOutput += ' [' + attributes + '];\n';
            }
          }
        }
      }

      graphvizOutput += '}\n';
      console.log(graphvizOutput);
      lastSupergraphGraphviz = graphvizOutput; // store raw .dot content so we can export it
      var viz_content = Viz(graphvizOutput);
      for (var key in supernodeToGraph) {
        cluster = idToCluster[key]
        viz_content = viz_content.replace("<title>"+supernodeToGraph[key]+"</title>","<title>#Nodes: "+cluster.vertices.length+"</title>")
      }
      return viz_content;
    }

    // convert SuperNodes, into a .dot file, render to svg
    // NOTE: to style the graph use CSS (see '.node text' above for example)
    function concreteGraphToGraphviz(nodes, edges, colors_dic, shape_dic) {
      var graphvizOutput = '';
      graphvizOutput += 'Digraph "Concretegraph" {\n';

      // go over each concrete node and write it in dot format
      nodes.forEach(function(node, index) {
        // update mapping for edge lookups
        // prepare graphviz node
        var attributes;
        if (concrete_nodes_dic[node]) {
          // server-side attributes, use these
          attributes = attributesToGraphViz(concrete_nodes_dic[node])
        } else {
          // no server-side attributes
          attributes = 'label=' + graphvizEscape(node) + ',shape=ellipse'
        }
        // if node is a cluster and not a concrete vertex, give it an id so we can hook up to the dendrogram
        if (attributes.length > 0) {
          attributes += ','
        }
        attributes += 'id=' + graphvizEscape(node);
        // write node to graphviz;
        var color = "white";//get_color(colors_dic[node]); TODO: improve this!
        var colors_map = ["aliceblue", "green", "cyan", "yellow","gray","cornsilk","salmon","deeppink","greenyellow"]
        if (node in colors_dic && colors_dic[node] < colors_map.length) {
          color = colors_map[colors_dic[node]]
        }
        var color_tag = "fillcolor=" + color;
        var style_tag = "style=filled";
        if (concrete_nodes_dic[node].style != undefined) {
          style_tag = "style=" + concrete_nodes_dic[node].style;
        }
        var shape = 'circle';
        if (node in shape_dic) {
          shape = shape_dic[node];
        }
        shape_tag ='shape=' + shape;
        graphvizOutput += '' + parseInt(node) + ' [' + shape_tag + ", " + attributes + ", " + color_tag + ", " +  style_tag + ', fixedsize=true,width=1,height=1' + '];\n';
        <!--console.log(parseInt(node) + ' [' + shape_tag + ", " + attributes + ", " + color_tag + ', fixedsize=true,width=1,height=1' + '];\n');-->
      });

      // go over each concrete edge and write it in dot format
      edges.forEach(function(edge, index) {
        // join together edges from the original graph to form edges from/to clusters
        // for each target vertex, store array of attributes from edges contributing to this super-edge
        var attributes = '';
        if (edge.length == 3) {
          // server-side attributes, use these
          attributes = attributesToGraphViz(edge[2]);
        }
        graphvizOutput += '' + edge[0] + ' -> ' + edge[1];
        graphvizOutput += ' [' + attributes + '];\n';
      });
      graphvizOutput += '}\n';
      return graphvizOutput;
    }

    function present_concrete_graph(dotContent, nodes, transitions){
      // max RAM set in webapp_config.py
      var svgString = Viz(dotContent, {totalMemory: {{ VIZJS_MAX_RAM }}}); // TODO: FIXME add var from webapp_config.py
      svgString = svgString.replace("graph0", "graph1");
      console.log(svgString);
      document.getElementById('concrete_graph').innerHTML = svgString;
      concretegraph_svg_elem = $("#concrete_graph").find("svg")[0];
      concretegraph_svg_elem.id = 'svg_concrete_graph';

      nodes.forEach(function(d3Node) {
        var nodeElement = $('#' + d3Node);
      });

      svg_concrete_graph = d3.select('#svg_concrete_graph');

      zoom_concrete_graph = d3.zoom()
        .scaleExtent([1 / 2, 4])
        .on("zoom", zoomed_concrete_graph);

      svg_concrete_graph.style("fill", "none")
        .style("pointer-events", "all")
        .call(zoom_concrete_graph);

      // read SVG transform matrix, convert to d3-zoom object, set as initial zoom. ugh.
      // this stops the super-state graph jumping on first zoom
      // console.log(document)
      // console.log(document.getElementById('graph0'));
      // graph_obj = document.getElementsByClassName('graph')[1];
      // console.log(graph_obj);
      var initialTransform = document.getElementById('graph1').transform.baseVal.consolidate().matrix;
      if (initialTransform.a != initialTransform.d) {
        alert('svg zoom on concretegraph does not preserve aspect ratio. UNSUPPORTED!');
      }
      var asZoomTransform = d3.zoomIdentity.translate(initialTransform.e, initialTransform.f).scale(initialTransform.a);
      // set initial transform
      svg_concrete_graph.call(zoom_concrete_graph.transform, asZoomTransform);

    }


    function getActiveClusters(root) {
      var active = [];

      function getRecursive(node) {
        // an active node has no children for now
        if (node.children) {
          node.children.forEach(getRecursive);
        } else {
          // if not actually a leaf node, it becomes a node in the super-state graph
          if (node._children) {
            active.push(node);
          } else {
            // leaf node, make all its contained vertices nodes in the super-state graph
            console.log(node);
            idToCluster[node.data.id].vertices.forEach(function(vertex) {
              // TODO(roee): massive hack, wrap fake cluster with extra fake cluster
              // mark it as a concrete vertex so that we don't eliminate self-edges
              // during display
              active.push({
                data: idToCluster[vertex],
                parent: node.parent
              });
            });
          }
        }
      }
      getRecursive(root);
      return active;
    }

    $('#btn_expand_all').click(function() {
      expandAll(root);
      update(root);
    });

    $('#btn_collapse_all').click(function() {
      root.children.forEach(collapse);
      collapse(root);
      update(root);
    });

  }); // d3.json
</script>
{% endblock %}
